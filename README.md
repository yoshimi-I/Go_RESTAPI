# Go言語チュートリアル
- 文法の解説と簡単なAPIを設計するところまでをまとめます。
- 独学のため間違いがあったらごめんなさい
# 目次
1. [まず最初にやること(環境構築)](#anchor1)
2. [パッケージってなんやねん](#anchor2)
3. [簡単な文法解説](#anchor3)
- 1. [変数宣言](#anchor4)
  2. [基本型](#anchor5)
  3. [配列とスライス](#anchor6)
  4. [インターフェース型](#anchor7)
  5. [定数](#anchor8)
  6. [関数](#anchor9)
# 1. まず最初にやること(環境構築) <a id="anchor1"></a>
1. docker-composeからGoのイメージの取得
    - 簡単にいうとbuildでイメージの作成を行い,up -dでイメージをもとにコンテナを立ち上げる。
    ```
    docker compose build 
    docker cmpose up -d　
    ```
2. modファイルの初期化
    ```
    go mod init github.com/yoshimi-I/Go_RESTAPI
    ```
- といった感じでリポジトリのurlのhttps:以降をinitの後に続けたものをターミナルに打ち込む。
- そうすることでgo.modというバージョンを管理するファイルが作られる。
  - これにパッケージをインポートいていく感じですね、Reactでいうpackage.jsonみたいなやつ
# 2. パッケージってなんやねん <a id="anchor2"></a>
```
package main

import "fmt"

func main() {
	fmt.Println("こんにちは")
}
```
- 上にこんにちはと出力する最小限のプログラムを書いた
- このようにGoは関数型言語であり主にmainパッケージの中のmain関数のみが読まれるため(ルール)、それ以外の関数だったり、パッケージだったりはインポートして補助的な役割で使っていくことになる
- C言語に似ていますね
## 使い方
- 今回出力するにあたり、import fmt と記載されているわけだが、これは実は
```
package fmt
~~~~~~~~
~~~~~~~~
func Println(a ...any) (n int, err error) {
	return Fprintln(os.Stdout, a...)
}
```
というGoがデフォルトで持っている,fmtパッケージの中のPrintln関数を使っていたというわけである。
- 使う場合はimportに使いたいpackageを記載して
```
package名.関数名
```
- といったように使用する。

# 3. 簡単な文法解説　<a id="anchor3"></a>
## 1. 変数宣言　<a id="anchor4"></a>
  ```
  関数の外では
  var i int = 100

  関数の中では
  i := 100
  ```
  - 簡単にいうと関数の中では型を省略することができる。(基本はこっち使う)
  - 少し変わってるのは型の指定を変数宣言の後に行うこと(Javaとは違う)
  - 基本的に宣言した型はどこかしらで使わないとエラーになる
    - そのため引数を２つとるような場合は１つを破棄することで対処する
    ```
    i,_ = strconv.Atoi(s)
    ```
    みたいな感じ
## 2. 基本型　<a id="anchor5"></a>
- 基本的に型に優先順位はないので、同じ型同士でないと計算ができない(C言語と違う)
- 以下に基本的な型を表示する
```
int
float
bool
string
byte
```
- ここら辺はまぁ他の静的型付け言語と一緒なので解説は省略します。
## 3. 配列とスライス　<a id="anchor6"></a>
- Go言語の配列はC言語の配列と同じく後から大きさの変更が効かない
- そこで動的な配列として用意されているのがスライスである。
- 基本的に他の言語の配列はGO言語のスライスだと思うと良い
```
配列
var arr1 [3]int = [3]int{1,23,456}
arr1 := [3]int{1,23,456}

配列(要素数の省略)
arr3 := [...]int{1,2,34,5}

スライス
slice0 := []int {1, 2, 3}
slice1 := make([]int, 3, 5)
```
- ちなみに変数に配列,スライスを代入した場合はそれぞれ違う挙動を示す。
- 例えば
```
slice := []int{1,2,3,4,5}
slice2 := slice

>> &slice[0]: 0xc000058100
>> &slice2[0]: 0xc000058100
```
- とやるとsliceとslice2のポインタ値は別のところを指すため、これは値わたしとなっている。
- 逆にスライスは参照渡し。
### 配列からスライスの作成
```
array := [5]int{1, 2, 3, 4, 5}
slice := array[:]

>> reflect.TypeOf(array): [5]int
>> reflect.TypeOf(slice): []int
>> array: [1 2 3 4 5]
>> slice: [1 2 3 4 5]
>> &array[0]: 0xc0000480c0
>> &slice[0]: 0xc0000480c0
```
## 4. インターフェース型　<a id="anchor7"></a>
- 初期値はnil(他の言語でいうところのnull型)
- 全ての型と互換性を持つ

## 5.定数 <a id="anchor8"></a>
- 基本的には関数の外に書く
  ```
  const Pi = 3.14
  const pi = 3.1

  以下のようにもかける
  const(
    A = 1
    B = 2
    c = 3
    d = 4
  )
  ```
- このように大文字だとJavaでいうところのpublic,小文字にするとパッケージの外では参照できないprivateとなる。
- またconstは型を指定しても指定しなくても作成することができる。
  ```
  const a = 1
  const b int = 12
  ```
  といった具合である。
## 6.関数 <a id="anchor9"></a>
- Go言語の関数は他の言語と違ってかなり色々できる。
### 1. 基本型(見慣れたやつ)
```
func test(a int,b int)int{
  return a + b
}
```
- これが一番基本的な型
- 変数 型の順番で引数をとり,その後に返り値の型をとる
### 2. 引数が2つあるやつ
```
func test(a,b int)(int,int){
  c := a + b
  d := a-b
  return c,d
}
```
- このように返り値の型に2つ代入すると返り値を2つとることができる。
- C言語とかだとポインタを使ってたけど、そんなことしなくてもいいのはでかいなぁ
### 引数にもう返り値の変数を指定するやつ
```
func test(a,b int)(result int){
  result = a+b
  return
}
```
- ポイントとしては返り値の場所に型だけではなく、変数名を入れることでreturnした時にその変数が必ず帰るよう指定している。
- またresultを最初に宣言しているので:=とする必要がない

